## 2/12 Day34 実技(Javaプログラミング実習Ⅱ)⑯
[joytas.net/Day34](https://joytas.net/%e8%a8%93%e7%b7%b4/day34).
### 1限目(9:00-9:50)
1. 教科書11.4 インタフェースP435~
	- 抽象メソッドを上に辿ると
		1. 抽象メソッドが増える
			- 「内容は確定できないが、一応存在する」という抽象メソッドが現れ始めます。
		1. 抽象メソッドやフィールドが減っていく
			- クラスに定義してある抽象メソッドやフィールドが減っていきます。
			> どんどんあいまいなものになっていく
1. インタフェース(interface)
	- インタフェースとして特別扱いできる2つの条件
		1. すべてのメソッドは抽象メソッドである。
		1. 基本的にフィールドを1つも持たない。
	- インタフェースの宣言
	~~~java
	public interface インタフェース名{
	}
	~~~
	- Code 11-12 インタフェースとして宣言したCreature
	~~~java
	public interface Creature{
		public abstract void run();
	}
	~~~
	- Code 11-13 一般的な書き方をしたインタフェース
	~~~java
	public interface Creature{
		void run();
	}
	~~~
	- インタフェースにおける定数宣言
	~~~java
	public intarface Circle{
		double PI=3.141592;
	}
	~~~
	> 自動的にpublic static finalが補われる
	- インタフェースの実装
	~~~java
	public class クラス名 implements インタフェース名{
	}
	~~~
	- 実装(implements)  
		実装する(implements)という用語が使われるのは、親インタフェースで未定だった各メソッドの内容をオーバーライドして実装し確定させるから。
	- インタフェースの効果
		1. 同じインタフェースをimplementsする複数の子クラスたちに、共通のメソッド群を実装するよう強制できる。
		1. あるクラスがインタフェースを実装していれば、少なくともそのインタフェースが定めたメソッドは持っていることが保証される。
---
### 2限目(10:00-10:50)
1. 教科書11.4 インタフェースP435~のつづき
	- クラスにはないインタフェースの特権
		異なる実装が衝突する問題が発生しないため、複数の親インタフェースによる多重継承が認められている。
	- インタフェースによる多重継承
	~~~java
	public class クラス名 implements 親インタフェース名1,親インタフェース名2{
	}
	~~~
	- インタフェースの継承

	|継承元|継承先|使用するキーワード|継承元の数|
	|---|---|---|---|
	|クラス|クラス|extends|1つ|
	|インタフェース|クラス|impements|1つ以上|
	|インタフェース|インタフェース|extends|1つ以上|
	- extendsとimplementsの両方を使ったクラス定義
	~~~java
	public class クラス名 extends 親クラスimplements 親インタフェース1,親インタフェース2{
	}
	~~~
	- アクセス修飾子

	|制限のレベル|名称|指定方法|アクセスを許可する範囲|
	|---|---|---|---|
	|制限が厳しい|private|private|自分自身のクラスのみ|
	|↑|package private|(何も書かない)|自分と同じパッケージに属するクラス|
	|↓|protected|protected|自分と同じパッケージに属するか、自分を継承した子クラス|
	|制限が緩い|public|public|すべてのクラス|
---
### 3限目(11:00-11:50)
1. 教科書 12 多態性P460~
	- 多態性とは  
		多態性(polymorphism)はオブジェクト指向プログラミングを支える3大機能
	- 多態性のあいまいなイメージ  
		「あるものを、あえてザックリ捉える」ことで、さまざまなメリットを享受しようという機能。
	- SuperHeroを「ザックリCharacterとして捉える」書き方  
		このときCharacterは箱、中身がSuperHeroと捉えるとわかりやすい
		~~~java
		Character c=new SuperHero();
		~~~  
	- 抽象クラスやインタフェースの型
		抽象クラスやインタフェースからインスタンスを生み出すことはできないが、それらの型を利用することは可能。
	- あいまいな型の箱へのインスタンスの代入
		インスタンスをあいまいに捉えることとなり、「厳密には何型のインスタンスだったか」がわからなくなってしまう。
	- 「箱の型」と「中身の型」
		- 箱の型 どのメソッドを「呼べるか」を決定する。
		- 中身の型 メソッドが呼ばれたら、「どう動くか」を決定する。
---
### 4限目(12:35-13:25)
1. 教科書 12 多態性P460~のつづき
	- キャスト演算子で型を変換する
	~~~java
	Character c=new Wizard();
	Wizard w=(Wizard)c;
	~~~
	> あいまいな型に入っている中身を厳密な型に代入するのはダウンキャスト(down cast)という
	- 安全にキャストできるかを判定する
	~~~java
	変数 instanceof 型名
	~~~
	> 変数を型名の箱に代入可能ならばtrueが帰る
---
### 5限目(13:35-14:25)
1. 教科書 12 多態性P460~のつづき
	- ザックリ利用しても、ちゃんと動く
		1. ザックリ捉えてまとめて扱う
			厳密には異なるインスタンスをまとめて扱うことができる。
		1. 「インスタンスは何型の箱に入っていようと、自身の型のメソッドが動作する」という原則がある。
---
### 質疑応答(14:25-15:25)
オブジェクト指向プログラミングにおけるデザインパターン
[デザインパターン](https://www.techscore.com/tech/DesignPattern/index.html/).  
[Gang of Fourデザインパターン学習](https://qiita.com/takumi0619/items/03986742efbb7e3a9bbe).
---
> Written with vim
